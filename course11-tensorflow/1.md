# TensorFlow实训任务

## 实验背景
TensorFlow是Google开发的开源软件库，用于机器学习。它能够在所有Linux、Windows和MacOS平台上的CPU和GPU上运行。 Tensorflow可用于设计、实施和训练受大脑结构和功能启发的深度学习模型。

## 实验目的
本次试验将逐步指导使用TensorFlow实现简单的神经网络。著名的鸢尾花数据集在此用于训练，然后将给定的花分类到正确的类型。鸢尾花数据集包含3种“Setosa”、“Versicolor”和“Virginica”。为了识别每种花型，有4种萼片长度、萼片宽度、花瓣长度和花瓣宽度的属性。我们将实施一个神经网络来使用这些因素识别正确的类型。

我们将使用训练数据集来训练我们的模型，然后将使用测试数据集来测试它的准确性。

## 实验步骤

#### 1. 导入数据
首先，我们需要读取.csv文件中的数据并导入它们。Pandas 可以用来轻松处理这个问题。

```
import tensorflow as tf
import pandas as pd
from matplotlib import pylot as plt
# read data from csv
train_data = pd.read_csv(“iris_training.csv”,names=[‘f1’,’f2’,’f3’,’f4’,’f5’])
test_data = pd.read_csv(“iris_test.csv”,names=[‘f1’,’f2’,’f3’,’f4’,’f5’])
```

Pandas中的read_csv（）函数将读取文件并将内容加载到指定的变量。作为函数的参数，我们需要指定文件的路径，而名称参数可以用来指定每个文件的列名。

#### 2. 编码类和数据分离

数据集中每种花都被编码为0、1和2。我们需要使用一种热门方法将它们编码为[1,0,0]，[0,1,0]和[0,0,1]。这将使网络的训练和优化变得容易，因为网络的输出也是以一种热门格式生成的。

那么我们需要定义训练集的x、y和测试集的x、y。

```
#encode results to onehot
train_data[‘f5’] = train_data[‘f5’].map({0:[1,0,0], 1:[0,1,0], 2:[0,0,1],})
test_data[‘f5’] = test_data[‘f5’].map({0:[1,0,0], 1:[0,1,0], 2:[0,0,1],})
#separate train data
train_x = train_data[[‘f1’,’f2’,’f3’,’f4’]]
train_y = train_data.ix[:,’f5’]
#separate test data
test_x = test_data[[‘f1’,’f2’,’f3’,’f4’]]
test_y = test_data.ix[:,’f5’]
```

#### 3. 定义权重，偏差和占位符

它需要为输入（X）、输出（Y）定义占位符，并定义网络的权重和偏差。这里我们有4列输入，因为数据集有4个特征和3列输出来映射3种类型的花。占位符的形状应该满足这一点。此外，权重矩阵的形状必须是4x3，并且偏差必须是3的矢量以将输入映射到输出（无隐藏层）。
```
#placeholders for inputs and outputs
	X = tf.placeholder(tf.float32, [None , 4])
	Y = tf.placeholder(tf.float32, [None , 3])
#weight and bias
weight = tf.Variable(tf.zeros([4,3]))
bias = tf.Variable(tf.zeros([3])) 
```

#### 4. 训练张量定义

然后我们需要通过一个激活函数发送输出，这里使用了tensorflow中可用的soft-max函数。为了训练模型，我们需要计算模型创建的输出中有多少误差的成本。我们在这里计算均方误差。然后我们可以训练模型，使用AdamOptimizer降低成本。

```
#output after going activation functions
output = tf.nn.softmax(tf.matmul(X, weight)+bias)
#cost function
cost = tf.reduce_mean(tf.square(Y-output))
#train model
train = tf.train.AdamOptimizer(0.01).minimize(cost) 
```

#### 5. 计算准确度

经过训练以检查我们的模型是否准确，我们需要将模型预测与实际结果进行比较。然后我们可以通过计算得到的正确结果来判断模型的准确性。

在这里，需要检查由我们的模型生成的输出是否等于实际结果（Y）。该模型将计算每种花的价值，这可以视为每种类型的概率。我们选择最有可能的类型。 argmax函数将返回最大值的索引。请记住，结果是一种one-hot形式，这种方法很容易让我们检查正确性。

在此之后，我们必须开始训练模型。在此之前，我们需要首先初始化所有全局变量，然后使用global_variables_initializer函数。

```
#check success and failure
success = tf.equal(tf.argmax(output, 1) , tf.argmax(Y, 1))
#calculate accuracy
accuracy = tf.reduce_mean(tf.cast(success, tf.float32))*100
#initialize variables
init = tf.gloab_variables_initializer()
```

#### 6. 训练模型

```
#start the tensorflow session
with tf.Session() as sess:
	costs = []
	sess.run(init)
	#train model 1000 times
	for I in range(1000):
		_,c = sess.run([train, cost], {X: train_x, Y: [t for t in train_y.as_matrix()]})
		costs.append(c)
	print(“Training finishd!”)
```

现在我们来训练我们的模型。张量执行必须在张量流中的一个会话内完成。因此，在培训之前我们需要创建一个会话，并且在完成所有事情之后，我们需要关闭会话。

上面的代码块被添加来创建tensorflow会话，并且该块中的所有内容都将具有该会话。此外，这个代码块能够在一切完成时自动关闭会话。

首先，执行变量初始张量，然后模型训练1000次。训练时，我们需要将训练数据集指定为X，将相应的结果指定为Y，因为训练tensorflow期望它们执行。在传递Y时，已经迭代并创建了一个新数组，以确保它具有与上面定义的形状相同的形状。在每次迭代中，跟踪成本以绘制图形以查看实际的训练。

#### 7. 绘制图形和检查准确性

最后，当训练过程结束时，绘制成本变化图并通过测试数据集测试模型的准确性。

```
#plot cost graph
plt.plot(range(1000),costs)
plt.title(“Cost Variation”)
plt.show()
print(“Accuracy: %.2f” %accuracy.eval({X: test_x, Y: [t for t in test_y.as_matrix()]}))
```

经过1000次训练迭代后，可以获得96.67％的准确度。